<?php

namespace App\Http\Controllers;

use App\Models\Page;
use App\Models\PageCategory;
use App\Models\Question;
use App\Models\SavedGrammarTest;
use App\Models\SiteTreeItem;
use App\Models\SiteTreeVariant;
use App\Services\AutoGeneratedTestService;
use App\Services\Theory\TextBlockQuestionMatcherService;
use Illuminate\Support\Collection;
use Illuminate\Support\Str;

class PageController extends Controller
{
    private const LEVEL_ORDER = ['A1', 'A2', 'B1', 'B2', 'C1', 'C2'];

    protected ?string $pageType = null;

    protected string $routePrefix = 'pages';

    protected string $indexView = 'engram.pages.index';

    protected ?string $categoryView = null;

    protected string $showView = 'engram.pages.show';

    protected string $sectionTitle = 'Теорія';

    protected ?array $siteTreeOrdering = null;

    public function __construct(
        private AutoGeneratedTestService $autoGeneratedTestService,
        private TextBlockQuestionMatcherService $textBlockQuestionMatcherService
    ) {}

    /**
     * Display the available categories with the first category's pages.
     */
    public function index()
    {
        $categories = $this->categoryList();
        $selectedCategory = $categories->first();
        $ordering = $this->siteTreeOrdering ?? [];

        $selectedCategory?->load([
            'pages' => fn ($query) => $this->applyPageTypeFilter($query)->orderBy('title'),
            'textBlocks',
        ]);

        if ($selectedCategory) {
            $selectedCategory->setRelation(
                'pages',
                $this->sortPagesWithOrdering($selectedCategory->pages, $ordering)
            );
        }

        return view($this->indexView, [
            'categories' => $categories,
            'selectedCategory' => $selectedCategory,
            'categoryPages' => $selectedCategory?->pages ?? collect(),
            'categoryDescription' => $this->categoryDescriptionData($selectedCategory),
            'routePrefix' => $this->routePrefix,
            'sectionTitle' => $this->sectionTitle,
        ]);
    }

    /**
     * Display a specific category with its related theory pages.
     */
    public function category(PageCategory $category)
    {
        $categories = $this->categoryList();
        $ordering = $this->siteTreeOrdering ?? [];
        $category->load([
            'pages' => fn ($query) => $this->applyPageTypeFilter($query)->orderBy('title'),
            'textBlocks',
            'tags',
        ]);

        $category->setRelation(
            'pages',
            $this->sortPagesWithOrdering($category->pages, $ordering)
        );

        // Get saved tests with matching tags
        $categoryTagIds = $category->tags->pluck('id')->toArray();
        $relatedTests = $this->getRelatedTestsWithMetadata($categoryTagIds, $category->tags);

        // Get auto-generated tests
        $autoGeneratedTests = $this->autoGeneratedTestService->generateTests($category->tags, $category->title);

        // Use category-specific view if defined, otherwise fall back to indexView
        $view = $this->categoryView ?? $this->indexView;

        return view($view, [
            'categories' => $categories,
            'selectedCategory' => $category,
            'categoryPages' => $category->pages,
            'categoryDescription' => $this->categoryDescriptionData($category),
            'relatedTests' => $relatedTests,
            'autoGeneratedTests' => $autoGeneratedTests,
            'routePrefix' => $this->routePrefix,
            'sectionTitle' => $this->sectionTitle,
        ]);
    }

    /**
     * Display the specified theory page using structured text blocks.
     */
    public function show(PageCategory $category, string $pageSlug)
    {
        $page = Page::query()
            ->with(['textBlocks.tags', 'tags'])
            ->forType($this->pageType)
            ->where('slug', $pageSlug)
            ->where('page_category_id', $category->getKey())
            ->firstOrFail();

        $blocks = $page->textBlocks;

        $subtitleBlock = $blocks->firstWhere(fn ($block) => $block->type === 'subtitle');

        $columns = [
            'left' => $blocks->filter(fn ($block) => $block->column === 'left'),
            'right' => $blocks->filter(fn ($block) => $block->column === 'right'),
        ];

        $locale = $subtitleBlock->locale
            ?? ($blocks->first()?->locale)
            ?? 'uk';

        $categories = $this->categoryList();

        $categoryPages = Page::query()
            ->where('page_category_id', $category->getKey())
            ->where('id', '!=', $page->getKey())
            ->forType($this->pageType)
            ->inRandomOrder()
            ->limit(3)
            ->get();

        if ($categoryPages->isEmpty()) {
            $categoryPages = collect([$page]);
        }

        // Get saved tests with matching tags
        $pageTagIds = $page->tags->pluck('id')->toArray();
        $relatedTests = $this->getRelatedTestsWithMetadata($pageTagIds, $page->tags);

        // Get auto-generated tests
        $autoGeneratedTests = $this->autoGeneratedTestService->generateTests($page->tags, $page->title);

        // Get practice questions for each text block (tag-based matching)
        $practiceQuestionsByBlock = $this->textBlockQuestionMatcherService->findQuestionsForTextBlocks($blocks, 5);

        $breadcrumbs = [
            ['label' => 'Home', 'url' => route('home')],
            ['label' => $this->sectionTitle, 'url' => route($this->routePrefix.'.index')],
            ['label' => $category->title, 'url' => route($this->routePrefix.'.category', $category->slug)],
            ['label' => $page->title],
        ];

        return view($this->showView, [
            'page' => $page,
            'breadcrumbs' => $breadcrumbs,
            'subtitleBlock' => $subtitleBlock,
            'columns' => $columns,
            'locale' => $locale,
            'categories' => $categories,
            'selectedCategory' => $category,
            'categoryPages' => $categoryPages,
            'relatedTests' => $relatedTests,
            'autoGeneratedTests' => $autoGeneratedTests,
            'practiceQuestionsByBlock' => $practiceQuestionsByBlock,
            'routePrefix' => $this->routePrefix,
            'sectionTitle' => $this->sectionTitle,
        ]);
    }

    protected function categoryList(): Collection
    {
        $categories = PageCategory::query()
            ->whereNull('parent_id')
            ->when($this->pageType === 'theory', fn ($query) => $query->where('type', 'theory'))
            ->with([
                'pages' => fn ($query) => $this->applyPageTypeFilter($query)->orderBy('title'),
                'children' => function ($query) {
                    $this->applyCategoryChildrenRelations($query);
                },
            ])
            ->withCount([
                'pages' => fn ($query) => $this->applyPageTypeFilter($query),
            ])
            ->orderBy('title')
            ->get();

        if ($this->pageType !== 'theory') {
            return $categories;
        }

        $availableTitles = $this->collectTheoryTitles($categories);
        $this->siteTreeOrdering = $this->siteTreeOrdering ?? $this->siteTreeLinkOrdering($availableTitles);
        $ordering = $this->siteTreeOrdering;

        return $this->applySiteTreeOrdering($categories, $ordering);
    }

    protected function applyCategoryChildrenRelations($query): void
    {
        $query->when($this->pageType === 'theory', fn ($q) => $q->where('type', 'theory'))
            ->withCount(['pages' => fn ($q) => $this->applyPageTypeFilter($q)])
            ->with([
                'pages' => fn ($q) => $this->applyPageTypeFilter($q)->orderBy('title'),
                'children' => function ($childQuery) {
                    $this->applyCategoryChildrenRelations($childQuery);
                },
            ])
            ->orderBy('title');
    }

    /**
     * Build a flattened ordering map for linked theory pages/categories based on the site tree variant.
     */
    protected function siteTreeLinkOrdering(array $availableTitles): array
    {
        $variant = SiteTreeVariant::getBase();

        if (! $variant) {
            return [];
        }

        $availableLookup = [];
        foreach ($availableTitles as $title) {
            $availableLookup[$title] = true;
            $availableLookup[$this->normalizeTitle($title)] = true;
        }

        $roots = SiteTreeItem::query()
            ->where('variant_id', $variant->id)
            ->whereNull('parent_id')
            ->with(['children' => function ($query) {
                $query->with('children')->orderBy('sort_order');
            }])
            ->orderBy('sort_order')
            ->get();

        $ordering = [];
        $position = 0;

        $collectOrdering = function ($items) use (&$collectOrdering, &$ordering, &$position, $availableLookup) {
            foreach ($items as $item) {
                $linkedTitle = $item->linked_page_title;

                if (! $linkedTitle) {
                    $linkedTitle = $this->findMatchingTheoryTitle($item->title, $availableLookup);
                }

                if ($linkedTitle) {
                    $normalized = $this->normalizeTitle($linkedTitle);
                    $ordering[$linkedTitle] = $position;
                    $ordering[$normalized] = $position;
                    $position++;
                }

                if ($item->children?->isNotEmpty()) {
                    $collectOrdering($item->children);
                }
            }
        };

        $collectOrdering($roots);

        return $ordering;
    }

    /**
     * Sort categories and nested pages according to the site tree ordering map.
     */
    protected function applySiteTreeOrdering(Collection $categories, array $ordering): Collection
    {
        $sorted = $categories->map(function (PageCategory $category) use ($ordering) {
            if ($category->relationLoaded('children')) {
                $category->setRelation('children', $this->applySiteTreeOrdering($category->children, $ordering));
            }

            if ($category->relationLoaded('pages')) {
                $category->setRelation('pages', $this->sortCollectionByOrdering($category->pages, $ordering, fn ($page) => $page->title));
            }

            $category->setAttribute('ordered_tree_items', $this->sortCategoryItems($category, $ordering));

            return $category;
        });

        return $this->sortCollectionByOrdering($sorted, $ordering, fn (PageCategory $category) => $category->title);
    }

    protected function sortPagesWithOrdering(Collection $pages, array $ordering): Collection
    {
        if ($pages->isEmpty()) {
            return $pages;
        }

        return $this->sortCollectionByOrdering($pages, $ordering, fn ($page) => $page->title);
    }

    /**
     * Sort a collection with site tree ordering first and fallback alphabetical.
     */
    protected function sortCollectionByOrdering(Collection $items, array $ordering, callable $getTitle): Collection
    {
        return $items
            ->sortBy(function ($item) use ($ordering, $getTitle) {
                $title = $getTitle($item);
                $order = $this->resolveOrderingValue($title, $ordering);

                return [$order, mb_strtolower($title)];
            })
            ->values();
    }

    /**
     * Combine child categories and pages into a single ordered collection that mirrors the site tree.
     */
    protected function sortCategoryItems(PageCategory $category, array $ordering): Collection
    {
        $items = collect();

        if ($category->relationLoaded('children') && $category->children->isNotEmpty()) {
            $items = $items->concat($category->children->map(fn (PageCategory $child) => [
                'type' => 'category',
                'model' => $child,
            ]));
        }

        if ($category->relationLoaded('pages') && $category->pages->isNotEmpty()) {
            $items = $items->concat($category->pages->map(fn ($page) => [
                'type' => 'page',
                'model' => $page,
            ]));
        }

        return $items
            ->sortBy(function ($item) use ($ordering) {
                $title = $item['model']->title;
                $order = $this->resolveOrderingValue($title, $ordering);

                return [$order, mb_strtolower($title)];
            })
            ->values();
    }

    protected function resolveOrderingValue(string $title, array $ordering): int
    {
        $normalized = $this->normalizeTitle($title);

        return $ordering[$title]
            ?? $ordering[$normalized]
            ?? PHP_INT_MAX;
    }

    protected function normalizeTitle(string $title): string
    {
        $cleaned = preg_replace('/^\d+[.\d\s]*\s*/u', '', $title) ?? $title;

        return Str::lower(trim($cleaned));
    }

    protected function findMatchingTheoryTitle(string $title, array $availableLookup): ?string
    {
        $normalizedTitle = $this->normalizeTitle($title);

        if (isset($availableLookup[$title])) {
            return $title;
        }

        return isset($availableLookup[$normalizedTitle]) ? $normalizedTitle : null;
    }

    protected function collectTheoryTitles(Collection $categories): array
    {
        $titles = [];

        foreach ($categories as $category) {
            $titles[] = $category->title;

            if ($category->relationLoaded('pages')) {
                foreach ($category->pages as $page) {
                    $titles[] = $page->title;
                }
            }

            if ($category->relationLoaded('children') && $category->children->isNotEmpty()) {
                $titles = array_merge($titles, $this->collectTheoryTitles($category->children));
            }
        }

        return $titles;
    }

    /**
     * Get all categories (flat list) that have pages of this type.
     * Used for cases where we need all categories regardless of hierarchy.
     */
    protected function allCategoriesFlat(): Collection
    {
        return PageCategory::query()
            ->whereHas('pages', fn ($query) => $this->applyPageTypeFilter($query))
            ->withCount([
                'pages' => fn ($query) => $this->applyPageTypeFilter($query),
            ])
            ->orderBy('title')
            ->get();
    }

    protected function categoryDescriptionData(?PageCategory $category): array
    {
        if (! $category) {
            return [
                'blocks' => collect(),
                'subtitleBlock' => null,
                'columns' => [
                    'left' => collect(),
                    'right' => collect(),
                ],
                'locale' => app()->getLocale() ?? 'uk',
                'hasBlocks' => false,
            ];
        }

        $blocks = $category->textBlocks ?? collect();
        $subtitleBlock = $blocks->firstWhere(fn ($block) => $block->type === 'subtitle');

        $columns = [
            'left' => $blocks->filter(fn ($block) => $block->column === 'left'),
            'right' => $blocks->filter(fn ($block) => $block->column === 'right'),
        ];

        $locale = $subtitleBlock->locale
            ?? ($blocks->first()?->locale)
            ?? app()->getLocale()
            ?? 'uk';

        return [
            'blocks' => $blocks,
            'subtitleBlock' => $subtitleBlock,
            'columns' => $columns,
            'locale' => $locale,
            'hasBlocks' => $blocks->isNotEmpty(),
        ];
    }

    /**
     * Get related tests with enriched metadata including level ranges and matching tags.
     *
     * This method fetches saved grammar tests that have questions matching the given tag IDs,
     * then enriches each test with computed properties:
     * - level_range: Collection of unique levels (e.g., ['A1', 'A2', 'B1']) sorted in proper order
     * - matching_tags: Collection of tag names that match between the source and test questions
     *
     * @param  array  $tagIds  Tag IDs to match against (from page or category)
     * @param  Collection  $tags  Tag collection for computing matching tag names
     * @return Collection Collection of SavedGrammarTest models with level_range and matching_tags properties
     */
    protected function getRelatedTestsWithMetadata(array $tagIds, Collection $tags): Collection
    {
        if (empty($tagIds)) {
            return collect();
        }

        $relatedTests = SavedGrammarTest::withMatchingTags($tagIds)->orderBy('name')->get();

        if ($relatedTests->isEmpty()) {
            return collect();
        }

        // Get all question UUIDs for all tests at once
        $allQuestionUuids = $relatedTests->flatMap(fn ($test) => $test->questionLinks->pluck('question_uuid'))->unique()->toArray();

        // Fetch all questions with their tags in one query
        $allQuestions = ! empty($allQuestionUuids)
            ? Question::whereIn('uuid', $allQuestionUuids)->with('tags')->get()->keyBy('uuid')
            : collect();

        $levelOrder = array_flip(self::LEVEL_ORDER);

        return $relatedTests->map(function ($test) use ($allQuestions, $tagIds, $tags, $levelOrder) {
            $questionUuids = $test->questionLinks->pluck('question_uuid')->toArray();

            if (! empty($questionUuids)) {
                // Get questions for this test from the pre-loaded collection
                $testQuestions = collect($questionUuids)
                    ->map(fn ($uuid) => $allQuestions->get($uuid))
                    ->filter();

                // Extract unique levels and sort them
                $levels = $testQuestions->pluck('level')->filter()->unique();
                $levels = $levels->sortBy(fn ($lvl) => $levelOrder[$lvl] ?? 99)->values();

                // Find matching tags
                $testTagIds = $testQuestions->pluck('tags')->flatten()->pluck('id')->unique()->toArray();
                $matchingTagIds = array_intersect($tagIds, $testTagIds);
                $matchingTags = $tags->whereIn('id', $matchingTagIds)->pluck('name');

                // Add computed properties
                $test->level_range = $levels;
                $test->matching_tags = $matchingTags;
            } else {
                $test->level_range = collect();
                $test->matching_tags = collect();
            }

            return $test;
        });
    }

    protected function applyPageTypeFilter($query)
    {
        return $this->pageType === null
            ? $query->whereNull('type')
            : $query->where('type', $this->pageType);
    }
}
